<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DP总结</title>
      <link href="/2019/08/21/DP%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/DP%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背包-mathbf-DP"><a href="#背包-mathbf-DP" class="headerlink" title="背包 $\mathbf{DP}$"></a>背包 $\mathbf{DP}$</h1><p>$DP$ 的背包问题是最基础的 $DP$ 了，分为 $01$ 背包，完全背包和多重背包。</p><h2 id="mathbf-01-背包"><a href="#mathbf-01-背包" class="headerlink" title="$\mathbf{01}$ 背包"></a>$\mathbf{01}$ 背包</h2><p>$01$ 背包基本模型，背包的总体积为 $V$ ，总共有 $n$<br>件物体，每件物品的体积为 $v_i$ ，价值为 $w_i$<br>，每件物品只有一个，选择一个集合 $\mathbb{S}$ ，在满足<br>$\sum_{i\in \mathbb{S}} v_i\leq V$ 的前提下最大化<br>$\sum_{i\in \mathbb{S}} w_i$<br>。可以很快推得状态转移方程为：$dp[i]=\max(dp[i],dp[i-v[j]]+w[j])$<br>时间复杂度为 $\Theta(n^2)$ 。</p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包基本模型，背包的总体积为 $V$ ，总共有 $n$<br>件物体，每件物品的体积为 $v_i$，价值为 $w_i$<br>，每个物品有无限多个，选择一个集合 $\mathbb{S}$ ，在满足<br>$\sum_{i\in \mathbb{S}} v_i\leq V$ 的前提下最大化<br>$\sum_{i\in \mathbb{S}} w_i$ 。其实就是在 $01$<br>背包的基础上做了一点修改。 $01$<br>背包每件物品都只有一个，所有我们枚举物品时需要倒序枚举防止重复。完全背包允许重复，我们应该正序枚举。状态转移方程仍为：$dp[i]=\max(dp[i],dp[i-v[j]]+w[j])$<br>时间复杂度为 $\Theta(n^2)$ 。</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包基本模型，背包的总体积为 $V$ ，总共有 $n$<br>件物体，每件物品的体积为 $v_i$ ，价值为 $w_i$ ，每个物品有 $n_i$<br>个，选择一个集合 $\mathbb{S}$ ，在满足<br>$\sum_{i\in \mathbb{S}} v_i\leq V$ 的前提下最大化<br>$\sum_{i\in \mathbb{S}} w_i$ 。考虑分解为 $01$ 背包，将每个物体拆分成<br>$n_i$ 个，再进行 $DP$ 。这样的时间复杂度为<br>$\Theta((\sum_{i=1}^n n_i)^2)$<br>。考虑优化。我们可以尽量少的进行拆分，使用二进制拆分将一种物品拆分为<br>$2^k (k=0,1,2 \cdots)$<br>个为一个新物品，这样可以满足取任意个，不影响答案。时间复杂度降低为<br>$\Theta((\sum_{i=1}^n \log_2 n_i)^2)$</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>一般分组背包问题中，每组中只能选择一件物品。设 $dp[i][j]$ 代表前 $i$<br>组物品构成体积为 $j$ 的背包所能取得的最大价值和。状态转移方程易得<br>$dp[i][j]=\max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])$</p><h1 id="树形-mathbf-DP"><a href="#树形-mathbf-DP" class="headerlink" title="树形 $\mathbf{DP}$"></a>树形 $\mathbf{DP}$</h1><p>树形 $DP$ 的一般形式都是对子树的信息进行归并，其本质是 $dfs/bfs$<br>过程中的统计。有些时候，还会涉及组合等方面的知识。时间复杂度一般为<br>$\Theta(n)$ 。</p><h1 id="区间-mathbf-DP"><a href="#区间-mathbf-DP" class="headerlink" title="区间 $\mathbf{DP}$"></a>区间 $\mathbf{DP}$</h1><p>区间 $DP$ 的本质就是对区间信息的合并。在区间 $DP$<br>中，我们可以通过对区间信息的合并，解决一系列问题。</p><h1 id="数位-mathbf-DP"><a href="#数位-mathbf-DP" class="headerlink" title="数位 $\mathbf{DP}$"></a>数位 $\mathbf{DP}$</h1><p>数位 $DP$ 的一般形式是求出在给定区间 $[L,R]$ 内，符合条件 $f(i)$ 的数<br>$i$ 的个数。条件 $f(i)$<br>一般与数的大小无关，而与数的组成有关。一般使用记忆化搜索实现数位 $DP$<br>。从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。一般来说，数位<br>$DP$ 解决区间 $[L,R]$ 的时候，会将其变成 $[0/1,R]-[0/1,L-1]$ 。</p><h1 id="状态压缩-mathbf-DP"><a href="#状态压缩-mathbf-DP" class="headerlink" title="状态压缩 $\mathbf{DP}$"></a>状态压缩 $\mathbf{DP}$</h1><p>一般来说，使用状压 $DP$<br>是因为状态转移不得不使用到更加细节的信息，但如果细节信息单独储存又没有足够的空间，于是考虑用一个数表示一个状态，用这个数的二进制来储存细节信息。状压<br>$DP$ 需要大量的位运算技巧，现列举一些常用技巧：</p><ul><li>取出数字 $x$ 第 $i$ 位： $((x&gt;&gt;(i-1))\&amp;1$ 。</li><li>将数字 $x$ 第 $i$ 位取反： $x^{\land}=(1&lt;&lt;(i-1))$ 。</li><li>将数字 $x$ 第 $i$ 位置 $1$ ： $x|=(1&lt;&lt;(i-1))$ 。</li><li>将数字 $x$ 第 $i$ 位置 $0$ ： $x\&amp;=(1&lt;&lt;(i-1))$ 。</li><li>将数字 $x$ 最靠右的 $1$ 去掉： $x=x\&amp;(x-1)$ 。</li><li>取出数字 $x$ 最靠右的 $1$ ： $x\&amp;(-x)$ 。</li><li>判断数字 $x$ 是否有两个连续的 $1$ ： $if(x\&amp;(x&lt;&lt;1))$ 。\<br>一般来说，状压 $DP$ 数据范围在 $20$ 左右，可以用一个 $int$ 储存状态。</li></ul><h1 id="概率-amp-期望-mathbf-DP"><a href="#概率-amp-期望-mathbf-DP" class="headerlink" title="概率&amp;期望 $\mathbf{DP}$"></a>概率&amp;期望 $\mathbf{DP}$</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p>概率亦称”或然率”。它反映随机事件出现的可能性大小。首先列举一些公式:<br>$P(\mathbb{S}-A)=1-P(A)$ $P(A\cup B)=P(A)+P(B)-P(A\cap B)$ 定义如果<br>$A$ 发生，那么 $B$ 发生的概率为 $P(B|A)$ ，可以得到<br>$P(B|A)=\frac{P(A\cap B)}{P(A)}$ 假如有 $n$ 个事件 $B_1,B_2,B_3\cdots$<br>，且有 $\forall i,\forall j,B_i\cap B_j=\varnothing$<br>，$\bigcup_{i=1}^n B_i=\mathbb{S}$ ，那么有全概率公式<br>$P(A)=\sum_{i=1}^n P(B_i)\cdot P(A|B_i)$ 还有一个贝利叶公式<br>$P(B|A)=\frac{P(B)\cdot P(A|B)}{P(A)}$ 求概率是可以根据需要使用。</p><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>数学期望，简称期望，是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。期望的基本算法为<br>$E(x)=\sum_{i=1}^{\infty} x_i\cdot p_i$ 。期望具有可加性，即<br>$E(x+y)=E(x)+E(y)$ ，也有 $E(a\cdot x)=a\cdot E(x)$ 。在 $DP$ 时经常使用这一性质。</p><h1 id="mathbf-DP-优化"><a href="#mathbf-DP-优化" class="headerlink" title="$\mathbf{DP}$ 优化"></a>$\mathbf{DP}$ 优化</h1><h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><p>单调队列是一种数据结构，通过双端队列实现在 $\Theta(1)$<br>的时间复杂度内获得区间最值。在许多转移方程带 $\max \min$ 的 $DP$<br>中，它可以很好地优化。</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>有一类问题，将n个物品分为连续的若干份，每分一次会通过一个计算方式产生一个代价，问代价最大/最小是多少。考虑<br>$DP$ ，容易想到状态转移方程为<br>$dp[i]=\min(\max)\left\{dp[j]+val(i,j)\right\}$ 算法复杂度为<br>$\Theta(n^2)$<br>当代价为该段物品的价格之和时，可以用单调队列优化解决。但是当代价为该段物品的价格之和的平方，即<br>$dp[i]=\min(\max)\left\{dp[j]+(sum[i]-sum[j])^2\right\}$<br>此时单调队列不可维护，此时考虑斜率优化。设 $\exists k(j&gt;k)$<br>使得转移更优。那么可得<br>$dp[j]+(sum[i]-sum[j])^2&lt;dp[k]+(sum[i]-sum[k])^2$ 展开整理，得<br>$dp[j]-dp[k]+sum[j]^2-sum[k]^2&lt;2\cdot sum[i]\cdot (sum[j]-sum[k])$<br>再次整理，将其化为分式<br>$\frac{dp[j]-dp[k]+sum[j]^2-sum[k]^2}{sum[j]-sum[k]}&lt;2\cdot sum[i]$ 令<br>$f(x)=dp[x]+sum[x]^2$ 可得 $\frac{f(j)-f(k)}{sum[j]-sum[k]}&lt;2\cdot sum[i]$<br>观察这个式子，发现其很像斜率，在空间中绘出点 $(sum[x],f(x))$<br>，可以发现转移的最优的点始终在一个下凸壳上，用数据结构维护即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构总结</title>
      <link href="/2019/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><p>基础数据结构包括数组，链表，栈，队列等，过于基础，再次不在赘述。</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。首先把每个点指向的父亲结点初始化为自己，然后根据要求进行查找和合并。合并的时间复杂度是<br>$\Theta(1)$ 的，而查找的时间复杂度与链长有关，最坏情况下是 $\Theta(n)$<br>的。</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>可以发现，查找时的路径上有哪些点我们并不关心，我们只关心根结点是哪个。于是可以想到，我们在查找的时候同时把自己的父亲结点指向根结点，就可以有效的减少链的长度。这样优化后合并的时间复杂度不变，而查找的时间复杂度降为<br>$\Theta(\alpha(n))$ ，几乎也可以看做常数。</p><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>在实际问题中，我们经常需要在并查集中记录权值，然后在合并的时候特殊处理。这种问题需要根据实际情况处理。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="普通的堆"><a href="#普通的堆" class="headerlink" title="普通的堆"></a>普通的堆</h2><p>堆是一颗特殊的完全二叉树，堆中的结点总满足按照排序方式的不同，总是大于或小于其父亲结点，称为大根堆或小根堆（根结点最大或最小）。考虑插入一个元素，将其插入堆的末尾，然后与其父亲结点比较，如果不满足堆的性质则交换，并重复此过程直到满足堆的性质。考虑弹出根结点，将其与末尾元素交换后删除，然后让根结点与其儿子比较，如果不满足如果不满足堆的性质则交换，并重复此过程直到满足堆的性质。此方法插入和删除的时间复杂度均为<br>$\Theta(\log_2 n)$ 。</p><h2 id="STL-，-pb-text-ds"><a href="#STL-，-pb-text-ds" class="headerlink" title="$STL$，$pb\text{_}ds$"></a>$STL$，$pb\text{_}ds$</h2><p>在 $C++$ 的 $STL$ 和 $pb\text{_}ds$ 库中均含有 $priority\text{_}queue$<br>。调用后即可建堆。常数略大，但 $pb\text{_}ds$<br>中的一些堆时间复杂度与普通堆不同，在此不做深究。</p><h2 id="可并堆"><a href="#可并堆" class="headerlink" title="可并堆"></a>可并堆</h2><p>可并堆除了支持一般的堆的基本操作以外，还支持额外的合并操作。而可并堆有多种，包括斜堆，左偏树，二项堆，配对堆，斐波那契堆等。这里只讨论左偏树。\<br>左偏树是一种具有左偏性质的堆有序二叉树。每一个结点存储的信息包括左右子结点、关键值以及距离。左偏树具有以下性质：</p><ul><li>堆的性质</li><li>$dis[u]=dis[rson]+1$ 其中叶子结点的 $dis=0$</li><li>$dis[lson]\geq dis[rson]$\<br>因为左偏树左偏，于是我们把所有操作放在右子树中，降低复杂度。\<br>合并操作是可并堆的核心操作，令 $u$ 为 $u$ ， $v$<br>中权值较小的一个，然后继续向下合并，在 $u$ 的右子树最右链中找到第一个比<br>$v$ 大的位置,将 $v$ 作为其父亲,然后继续不断递归调用合并 $v$<br>的右子树和以该结点为根的右子树即可,同时维护相关信息即可。若右子树 $dis$<br>比左子树大,则交换两个子树。\<br>同时，左偏树也支持删除。首先把删除结点的权值赋为 $-1$<br>，然后合并其左右子树得到新的左偏树，我们再把得到的这个左偏树接到删除结点的父结点上，同时维护父结点的子结点信息。但是，删除掉结点后我们可能会发现不满足左偏性质了，那么我们就需要判断是否需要交换左右子树，并且要一直向上重复判断，直到到了某一结点时左偏性质没有被破坏了或者已经到了根结点。左偏树合并的最坏时间复杂度为<br>$\Theta(\log_2 n)$</li></ul><h1 id="mathbf-ST-表"><a href="#mathbf-ST-表" class="headerlink" title="$\mathbf{ST}$ 表"></a>$\mathbf{ST}$ 表</h1><p>$ST$ 表是可以在 $\Theta(n)$<br>的时间复杂度内求出区间最值的数据结构。首先考虑记录一段区间内的最值，最值支持区间重叠，即\<br>$\max{a,b,c}=\max(\max(a,b),\max(b,c))$ 考虑倍增，建立数组 $st[i][j]$<br>，意为从下标 $i$ 开始的连续 $2^j$ 个数的最值。显然可以用区间 $DP$<br>来预处理 $st[][]$ 。首先初始化 $st[i][0]=val[i]$ 状态转移方程如下：<br>$st[i][j]=\max(st[i][j-1],st[i+2^{j-1},j-1])$ 这样预处理时间复杂度为<br>$\Theta(n*\log_2 n)$ 。\<br>记询问区间长度为 $len$ ，我们从左端点向右找一段长为 $2^{\log_2 len}$<br>的区间，右端点向左也找一段长为 $2^{\log_2 len}$<br>的区间，显然这两段区间已经覆盖了整个区间，取最大值即可。当然为了保证询问复杂度为<br>$\Theta(1)$ ，我们需要提前预处理出每个<br>$\left\lfloor\log_2 n\right\rfloor$ 值。</p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>树状数组是一个在线的数据结构，它可以做到在 $\Theta(\log_2 n)$<br>的时间复杂度内进行单点修改和区间求和。算法思路是对于一个数组 $val[]$<br>，建立一个树状图 $bit[]$ ，其中 $bit[i]$ 为以 $i$ 为末尾的一段长为<br>$lowbit(i)$ 的区间和（其中 $lowbit(i)$ 指的是 $i$ 的二进制表示中末尾的<br>$1$ 的权值），可以发现，一个结点加上自己的 $lowbit$<br>就可以找到自己的父亲结点。</p><h2 id="单点修改-mathbf-modify"><a href="#单点修改-mathbf-modify" class="headerlink" title="单点修改 $\mathbf{modify}$"></a>单点修改 $\mathbf{modify}$</h2><p>考虑单点修改，修改 $val[i]$ 的值，需要修改 $bit[i]$<br>以及它的祖先。就是每次修改当前结点，然后加上自己的 $lowbit$<br>，重复此操作直到没有父结点。由于二进制中最多有 $\log_2 n$ 个 $1$<br>，所以时间复杂度为 $\Theta(\log_2 n)$ 。</p><h2 id="查询前缀和-mathbf-query"><a href="#查询前缀和-mathbf-query" class="headerlink" title="查询前缀和 $\mathbf{query}$"></a>查询前缀和 $\mathbf{query}$</h2><p>考虑询问，每次可以询问结点 $i$<br>的前缀和，每次将之前不重叠的区间加起来。就是每次通过减去自己的 $lowbit$<br>实现的。和修改一样时间复杂度为 $\Theta(\log_2 n)$ 。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h2><p>线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。若一个结点代表区间为<br>$[L,R]$ ，那么其左儿子代表的区间为 $[L,(L+R)/2]$ ，右儿子代表的区间为<br>$[(L+R)/2+1,R]$ ，所有叶子结点代表的区间长均为 $1$<br>。这样看，其实线段树也是一颗完全二叉树，所以可以用位运算来构造线段树（当然也可以动态开点）。对于一个非叶子结点<br>$nd$ ，可以用 $nd<em>2$ 表示其左儿子，用 $nd</em>2+1$ 表示其右儿子。</p><h2 id="区间修改-mathbf-modify"><a href="#区间修改-mathbf-modify" class="headerlink" title="区间修改 $\mathbf{modify}$"></a>区间修改 $\mathbf{modify}$</h2><p>单点修改其实可以归为区间修改的子问题，所以这里只讨论区间修改。考虑分块的思想，对于整个区间都要修改的结点，直接在该结点上打懒标记，对于零散的区间进行递归，找到所以需要修改的区间。线段树可以支持不止一个懒标记，但需要在下放的时候考虑顺序和相互影响。由于线段树有<br>$\log_2 n$ 层，所以时间复杂度为 $\Theta(\log_2 n)$ 。</p><h2 id="区间查询-mathbf-query"><a href="#区间查询-mathbf-query" class="headerlink" title="区间查询 $\mathbf{query}$"></a>区间查询 $\mathbf{query}$</h2><p>和区间修改一样，同样是分块的思想。对于整个区间都在查询区间内的结点，直接加上该结点的值，零散的区间进行递归。时间复杂度同样为<br>$\log_2 n$ 。</p><h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>权值线段树和线段树，唯一的本质的区别就是他们维护的东西不一样。权值线段树的下标就是值域，可能会有区间修改，区间询问，还可以打各种各样的标记。</p><h2 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h2><p>可持久化线段树又称主席树。用于查询区间第 $k$<br>大。主席树的主要思想就是：保存每次插入操作时的历史版本，以便查询区间第<br>$k$<br>大。主席树只需要支持单点修改，也就是说每次修改只会影响一条链。考虑每次修改都新建一条链，在这条链上储存新的信息。如何查询区间第<br>$k$ 大？考虑首先将问题简化，查询区间 $[1,R]$ 的第 $k$<br>大。其实我们只需要在初始时建一颗空树，然后按从小到大一次插入值，查询时找到插入<br>$r$<br>的历史版本，用权值线段树解决。在主席树中，维护的信息有前缀和的特点，所以<br>$[L,R]$ 区间的信息可以用 $[1,R]-[1,L-1]$ 来得到。同样用权值线段树解决。</p><h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>分块算法实质上是一种是通过分成多块后在每块上打标记以实现快速区间修改，区间查询的一种算法。其均摊时间复杂度为<br>$\Theta(\sqrt{n})$ 。\<br>为了使得其有着最稳定的时间复杂度，我们经常讲一个长度为 $n$ 的序列分为<br>$\sqrt{n}$ 个大小为 $\sqrt{n}$ 的块，如果 $n$<br>不是完全平方数，则序列最右端会多出一个角块</p><h2 id="区间修改-mathbf-modify-1"><a href="#区间修改-mathbf-modify-1" class="headerlink" title="区间修改 $\mathbf{modify}$"></a>区间修改 $\mathbf{modify}$</h2><p>考虑修改，当我们修改任意一个区间 $[L,R]$ 时，如果 $L$ 所在的块与 $R$<br>所在的块相同，则直接暴力修改即可，若其不在一个块但是块是相邻的，一样是暴力修改，若其块不相邻，我们先处理两边的边块角块，最后直接修改中间块即可，三种情况时间复杂度均为<br>$\Theta(\sqrt{n})$ 。</p><h2 id="区间查询-mathbf-query-1"><a href="#区间查询-mathbf-query-1" class="headerlink" title="区间查询 $\mathbf{query}$"></a>区间查询 $\mathbf{query}$</h2><p>和修改一样，查询的方法也是边角暴力，整块打标记。</p><h1 id="mathbf-Splay"><a href="#mathbf-Splay" class="headerlink" title="$\mathbf{Splay}$"></a>$\mathbf{Splay}$</h1><h2 id="数据结构简介-1"><a href="#数据结构简介-1" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>$Splay$ ，是一种二叉排序树，它能在 $\Theta(\log_2 n)$<br>内完成插入、查找和删除操作。因为 $Splay$<br>是一颗二叉排序树，所以它的每一个结点都应该满足如下性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于这个结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于或等于这个结点的值。\<br>我们知道，在对二叉树进行中序遍历时，会先遍历左子树，然后是自身，最后才是右子树。所以一颗二叉排序树的中序遍历是不严格单调递增的。我们在进行重构树时，也需要保证中序遍历不变。<br>$Splay$ 所有的操作时间复杂度都可以近似的看做 $\Theta(\log_2 n)$ 。</li></ul><h2 id="旋转操作-mathbf-rotate"><a href="#旋转操作-mathbf-rotate" class="headerlink" title="旋转操作 $\mathbf{rotate}$"></a>旋转操作 $\mathbf{rotate}$</h2><p>核心操作。 $Splay$<br>通过旋转操作来保持平衡。旋转时需要保证中序遍历不变，步骤如下：</p><ul><li>求出目标结点位于父亲结点的方向，并作为基本方向。</li><li>目标结点父亲的同向儿子 $-&gt;$ 目标结点的异向儿子。</li><li>目标结点爷爷的（左/右）儿子 $-&gt;$ 目标结点。</li><li>目标结点的异向儿子 $-&gt;$ 目标结点的父亲。</li></ul><h2 id="伸展操作-mathbf-splay"><a href="#伸展操作-mathbf-splay" class="headerlink" title="伸展操作 $\mathbf{splay}$"></a>伸展操作 $\mathbf{splay}$</h2><p>考虑旋转，将一个结点一直旋转至目标结点的儿子，如果目标结点为 $0$<br>，则表示旋转至根结点。其实只需要每次进行旋转后判断父亲是不是目标结点，如果爷爷，父亲与当前结点”三点一线”，我们就要先旋转父结点，再旋转当前结点，使这颗<br>$Splay$ 更平衡（这是一个很玄学的问题）。</p><h2 id="寻找操作-mathbf-find"><a href="#寻找操作-mathbf-find" class="headerlink" title="寻找操作 $\mathbf{find}$"></a>寻找操作 $\mathbf{find}$</h2><p>这是一个辅助操作，目的是把最大的小于等于指定值的结点（如果有这个值，则返回这个值，否则返回最大的小于这个值的结点）<br>$splay$<br>到根结点。操作很简单，只需要在每个结点处判断当前结点值是否小于指定值，再决定向左或向右,最后把找到的值<br>$splay$ 上来。</p><h2 id="插入操作-mathbf-insert"><a href="#插入操作-mathbf-insert" class="headerlink" title="插入操作 $\mathbf{insert}$"></a>插入操作 $\mathbf{insert}$</h2><p>这个操作的目的是向 $Splay$<br>里插入一个值。和上一个操作类似，也是需要在每个结点处判断当前结点值是否小于指定值，再决定向左或向右，如果结点存在则直接自增cnt的值。否则新建结点并与父结点连边。同时因为新建结点时可能会拉出一条链，为了保持<br>$Splay$ 的平衡，我们需要将该结点 $splay$ 到根。</p><h2 id="求第-mathbf-k-大-mathbf-kth"><a href="#求第-mathbf-k-大-mathbf-kth" class="headerlink" title="求第 $\mathbf{k}$ 大 $\mathbf{kth}$"></a>求第 $\mathbf{k}$ 大 $\mathbf{kth}$</h2><p>同样是从根结点开始向下搜，每次需要判断 $k$<br>与左子树大小，与（左子树大小+该结点 $cnt$<br>）的大小关系，再决定向左或向右，或是返回这个结点。</p><h2 id="求排名-mathbf-rank"><a href="#求排名-mathbf-rank" class="headerlink" title="求排名 $\mathbf{rank}$"></a>求排名 $\mathbf{rank}$</h2><p>只需要把这个值转到根，再返回根结点左子树大小即可。</p><h2 id="求前驱后继-mathbf-prev-amp-succ"><a href="#求前驱后继-mathbf-prev-amp-succ" class="headerlink" title="求前驱后继 $\mathbf{prev\&amp;succ}$"></a>求前驱后继 $\mathbf{prev\&amp;succ}$</h2><p>求指定值的前驱（比它小的数中最大的）只需要找到左子树中最右边的那一个，返回即可。同理，求指定值的后继（比它大的数中最小的），只需要找到右子树中最左边的那一个，返回即可。</p><h2 id="删除操作-mathbf-remove"><a href="#删除操作-mathbf-remove" class="headerlink" title="删除操作 $\mathbf{remove}$"></a>删除操作 $\mathbf{remove}$</h2><p>如果把 $prev(x)\quad splay$ 到根结点，把 $succ(x)\quad splay$ 到 $prev(x)$<br>的右儿子，那么 $succ(x)$<br>的左儿子只会有目标结点一个结点，删除方法显而易见。</p><h2 id="区间翻转-mathbf-reverse"><a href="#区间翻转-mathbf-reverse" class="headerlink" title="区间翻转 $\mathbf{reverse}$"></a>区间翻转 $\mathbf{reverse}$</h2><p>和线段树区间加一样，这个地方也运用了”懒标记”的思想。和\<br>$remove$ 操作类似，将 $[L,R]$ 区间提取出来，可以把 $L-1\quad splay$<br>到根结点，把 $R+1\quad splay$ 到根结点的儿子，再对这个区间打上”懒标记”。</p><h1 id="mathbf-Link-Cut-quad-Tree"><a href="#mathbf-Link-Cut-quad-Tree" class="headerlink" title="$\mathbf{Link-Cut\quad Tree}$"></a>$\mathbf{Link-Cut\quad Tree}$</h1><h2 id="数据结构简介-2"><a href="#数据结构简介-2" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>$Link-Cut\quad Tree$<br>是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用<br>$Splay$ 来维护每一条实路径。本质上， $Link-Cut\quad Tree$ 维护的是一个<br>$Splay$ 森林。 $Link-Cut\quad Tree$ 的所有操作时间复杂度均为均摊<br>$\Theta(\log_2 n)$ ，但常数略大。</p><h2 id="打通操作-mathbf-access"><a href="#打通操作-mathbf-access" class="headerlink" title="打通操作 $\mathbf{access}$"></a>打通操作 $\mathbf{access}$</h2><p>这是 $Link-Cut\quad Tree$ 最基础的操作，意思是将点 $x$<br>到原树中根结点之间的链丢到一个辅助树 $Splay$ 里面。每次将 $x$ 点 $splay$<br>到当前所在辅助树的根节点，将它的右儿子更新为上一个 $x$ ，然后令 $x$<br>跳到它的父节点，特别的，第一个 $x$ 的右儿子设为 $0$ 。</p><h2 id="找根操作-mathbf-findroot"><a href="#找根操作-mathbf-findroot" class="headerlink" title="找根操作 $\mathbf{findroot}$"></a>找根操作 $\mathbf{findroot}$</h2><p>我们可以通过 $x$ 向上找，用 $access$ 操作可以将 $x$ 和 $x$<br>的根结点放到一个 $Splay$ 里。又因为 $x$ 的左子树所有结点的权值 $&lt;x&lt;\quad x$<br>右子树所有结点的权值。而我们又知道，在执行完 $access$ 操作后，这课<br>$Splay$ 里面的结点权值最大的(深度最大的)就是 $x$<br>。于是我们可以将$x\quad splay$ 到这棵 $Splay$<br>的根结点，那么现在最左边的节点便是这课树的根结点了。</p><h2 id="换根操作-mathbf-makeroot"><a href="#换根操作-mathbf-makeroot" class="headerlink" title="换根操作 $\mathbf{makeroot}$"></a>换根操作 $\mathbf{makeroot}$</h2><p>具体操作是我们先将 $x$ 点与原树中的根打通一条链，那么现在它们就在同一棵<br>$Splay$ 里面了，可以发现 $x$<br>一定是在它所在的辅助树的中序遍历的最后一个的(因为它是这条链上最深的点)，我们把<br>$x\quad splay$ 到 $Splay$ 的根上，那么 $x$ 显然是没有右子树的，我们要实现将<br>$x$ 移到原树的根上，也就是将 $x$ 到根的这条链的深度全部翻转一遍，在<br>$Splay$ 上的体现就是将整棵树翻转一遍。</p><h2 id="提取操作-mathbf-split"><a href="#提取操作-mathbf-split" class="headerlink" title="提取操作 $\mathbf{split}$"></a>提取操作 $\mathbf{split}$</h2><p>这个操作是将 $x$ 到 $y$ 之间的那条路径丢到一棵辅助树里，并且这棵辅助树以<br>$y$ 节点为根(方便处理信息)。 $Splay$<br>维护的是原树中的一条链，我们不能保证 $x$ , $y$<br>会在同一条链里。所以我们可以先把 $x$ 变成原树的根节点，这样 $access(y)$<br>就会将 $x$ 到 $y$ 之间的所有节点丢到一个 $Splay$ 中了。最后来一个把<br>$y\quad splay$ 到根就可以达到目的。</p><h2 id="链接操作-mathbf-link"><a href="#链接操作-mathbf-link" class="headerlink" title="链接操作 $\mathbf{link}$"></a>链接操作 $\mathbf{link}$</h2><p>考虑 $Link-Cut\quad Tree$ 的本职工作：将 $x$ 和 $y$<br>所在树合并起来。首先将x点丢到树的根，然后去找找 $y$ 的根是不是 $x$<br>，如果不是说明 $x$ ， $y$ 不在一个树内，我们将 $x$ 的父节点设为 $y$<br>，也就相当于从 $y$ 到 $x$ 连了一条虚边。</p><h2 id="切断操作-mathbf-cut"><a href="#切断操作-mathbf-cut" class="headerlink" title="切断操作 $\mathbf{cut}$"></a>切断操作 $\mathbf{cut}$</h2><p>再考虑另一个操作，将 $x$ ， $y$ 分开。首先我们先把 $x$ ， $y$<br>之间的那条边用 $split$ 拎出来，因为 $x$ ， $y$ 是相邻的，所以 $y$<br>的左儿子一定是 $x$ ，将它们的父子关系取消即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论总结</title>
      <link href="/2019/08/21/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h1><h2 id="mathbf-Floyd-算法"><a href="#mathbf-Floyd-算法" class="headerlink" title="$\mathbf{Floyd}$ 算法"></a>$\mathbf{Floyd}$ 算法</h2><h3 id="思路简介"><a href="#思路简介" class="headerlink" title="思路简介"></a>思路简介</h3><p>$Floyd$ 算法的思想本质是一个 $DP$ ，首先枚举中间点 $k$ ，对于每条路径<br>$i-&gt;j$ ，判断此路径若经过点 $k$<br>是否更优。状态转移方程为 $dis[i][j]=\min(dis[i][k]+dis[k][j],dis[i][j])$<br>$Floyd$ 算法枚举先中间点 $k$ ，再枚举路径起点 $i$ 和终点 $j$<br>，每层循环枚举次数都是 $n$ ，故算法时间复杂度为 $\Theta(V^3)$ 。</p><h3 id="算法优劣"><a href="#算法优劣" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>$Floyd$ 算法是最短路算法中唯一的一个多元最短路算法，在 $\Theta(V^3)$<br>的时间内可以求出任意两点的最短路。并且可以处理副边权，但不能处理负环。同时，由于时间复杂度较高，应用不是特别广。</p><h2 id="mathbf-Dijkstra-算法"><a href="#mathbf-Dijkstra-算法" class="headerlink" title="$\mathbf{Dijkstra}$ 算法"></a>$\mathbf{Dijkstra}$ 算法</h2><h3 id="思路简介-1"><a href="#思路简介-1" class="headerlink" title="思路简介"></a>思路简介</h3><p>$Dijkstra$ 算法的思路是维护一个点集 $\mathbb{U}$<br>,点集内的点都是已经确定最短路的点。建立数组 $dis[]$<br>表示从源点出发到达每个点的最短路长度，每次从图中寻找离该集合最近的点 $v$<br>，并确定它的最短路长度 $dis[v]=dis[u]+w(u,v)$ （ $u$ 为点集中离 $v$<br>最近的点），然后将该点加入点集 $\mathbb{U}$ （也就是所谓的松弛操作）。\<br>$Dijkstra$ 算法需要进行 $n$<br>次松弛操作（每个点一次），每次松弛操作需要枚举所有点来寻找离点集最近的点，故算法时间复杂度为<br>$\Theta(V^2)$ 。\<br>考虑优化，我们需要在所有点中寻找离点集最近且不在点集中的点。换而言之，我们要在一个集合中寻找最小值。很容易联想到利用堆这种数据结构优化<br>$Dijkstra$ 算法。这样每次寻找最小值的时间复杂度降为 $\Theta(1)$<br>，每次加入点集后将相邻点插入堆中时间复杂度为 $\Theta(e\cdot \log_2 V)$ （ $e$<br>为该点边数），于是最后时间复杂度降为 $\Theta((V+E)\cdot \log_2 V)$ 。</p><h3 id="算法优劣-1"><a href="#算法优劣-1" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>$Dijkstra$ 算法是当前 $\mathcal{OI}$<br>中最主流的最短路算法，其应用范围广，基本不会被卡，但不能处理带负边权的情况。</p><h2 id="mathbf-Bellman-Ford-算法"><a href="#mathbf-Bellman-Ford-算法" class="headerlink" title="$\mathbf{Bellman-Ford}$ 算法"></a>$\mathbf{Bellman-Ford}$ 算法</h2><h3 id="思路简介-2"><a href="#思路简介-2" class="headerlink" title="思路简介"></a>思路简介</h3><p>$Bellman-Ford$ 算法最初的思路仍然像一个 $DP$ ，数组 $dis[i][j]$<br>代表从源点出发经过最多 $j$ 条边到达 $i$<br>点的最短路长度。状态转移方程显然$dis[i][j]=\min(dis[i][j-1],\min\left\{dis[k][j-1]+w(i,k)\right\})$<br>考虑对每个点的松弛操作改为对每条边进行松弛操作，每轮松弛操作中对每条边<br>$u-v$ 都进行一次松弛 $dis[v]=\min(dis[v],dis[u]+w(u,v))$ , $n-1$<br>轮松弛后即可得出源点到每个点的最短路。如果接下来还能对边进行松弛，则说明图中存在负环，最短路为负无穷。因为没有负环的图中最短路最多经过<br>$n-1$ 条边（每个点经过一次），如果一条最短路经过了多余 $n-1$<br>条边，则此图必定有负环。由上述思路，经过 $n-1$ 轮松弛，每轮松弛 $m$<br>条边，时间复杂度为 $\Theta(V\cdot E)$ 。</p><h3 id="算法优劣-2"><a href="#算法优劣-2" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>$Bellman-Ford$<br>算法可以在有负边权的图中找出最短路，并且可以判断图中有没有负环。其时间复杂度与边数有关，在稀疏图中表现优异，但在稠密图中（边数在<br>$1e6$ 左右）就会被卡。</p><h2 id="mathbf-SPFA-算法"><a href="#mathbf-SPFA-算法" class="headerlink" title="$\mathbf{SPFA}$ 算法"></a>$\mathbf{SPFA}$ 算法</h2><h3 id="思路简介-3"><a href="#思路简介-3" class="headerlink" title="思路简介"></a>思路简介</h3><p>$SPFA$ 算法的全称是 $Shortest\quad Path\quad Faster\quad Algorithm$ ，其本质是<br>$Bellman-Ford$<br>的队列优化。首先把起点入队，同时标记入队，然后重复以下操作直到队列为空：\<br>  -取出队首并标记出队。\<br>  -遍历与其相连的边，进行松弛操作。\<br>  -如果与其相连的点没有在队列中，就将其入队，并标记。\<br>如果有一个点入队次数超过 $n-1$ ，即代表有边被松弛超过 $n-1$<br>次，说明图中有负环。考虑每个点都入队 $n-1$ 次，这种情况就和朴素的<br>$Bellman-Ford$ 算法时间复杂度一致，为 $\Theta(V\cdot E)$ 。</p><h3 id="算法优劣-3"><a href="#算法优劣-3" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>$SPFA$ 曾一度被证明复杂度为 $\Theta(k\cdot E)$ （其中 $k$<br>为小常数），后证明此复杂度是错误的，所以 $SPFA$ 曾一度被卡。后有 $LLL$<br>， $mcfx$ 优化， $SLF$ ， $SLF$带容错， $SLF-swap$<br>，等一系列神仙优化，但最终还是可以被卡掉。但 $SPFA$<br>可以在随机数据的情况下更快判断负环，弥补的 $Dijkstra$<br>算法不能处理负环，负边权的缺陷。</p><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="mathbf-Prim-算法"><a href="#mathbf-Prim-算法" class="headerlink" title="$\mathbf{Prim}$ 算法"></a>$\mathbf{Prim}$ 算法</h2><h3 id="思路简介-4"><a href="#思路简介-4" class="headerlink" title="思路简介"></a>思路简介</h3><p>同 $Dijkstra$ 算法一样， $Prim$<br>算法的思路是也维护一个点集，点集内的点都是已经在最小生成树上的点。每次从图中寻找离该集合最近的点<br>$v$ ，加入集合，并将边 $e(u,v)$ （ $u$ 为点集中离 $v$<br>最近的点）加入最小生成树。同 $Dijkstra$ 算法一样， $Prim$<br>算法的时间复杂度也是 $\Theta(V^2)$ 。同理，也可以用堆优化至<br>$\Theta((V+E)\cdot \log_2 V)$</p><h3 id="算法优劣-4"><a href="#算法优劣-4" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>从时间复杂度的角度看，朴素的 $Prim$<br>算法与边数完全无关，适用于稠密图。优化后主要也是与点数有关。总体来看，<br>$Prim$ 算法适用于稠密图。</p><h2 id="mathbf-Kruskal-算法"><a href="#mathbf-Kruskal-算法" class="headerlink" title="$\mathbf{Kruskal}$ 算法"></a>$\mathbf{Kruskal}$ 算法</h2><h3 id="思路简介-5"><a href="#思路简介-5" class="headerlink" title="思路简介"></a>思路简介</h3><p>$Kruskal$<br>算法使用的数据结构”并查集”，它的思路是把边从小到大排序，然后对每条边检查两个端点是否在一个并查集中，若不在一个并查集中，则将其合并，将该边加入最小生成树，直到加入<br>$n-1$<br>条边后终止。时间复杂度为排序的时间加上对每条边进行判断，合并的时间，均摊时间复杂度为<br>$\Theta(E\cdot \log_2 E)$ 。</p><h3 id="算法优劣-5"><a href="#算法优劣-5" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>于上文的 $Prim$ 算法相比， $Kruskal$<br>算法复杂度只于边数有关，适用于稀疏图，同样也是最主流的最小生成树算法。</p><h1 id="有向图算法"><a href="#有向图算法" class="headerlink" title="有向图算法"></a>有向图算法</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是在有向图中寻找一个可行的拓扑序，使得每个点的前驱在该序列中都在这个点的前面。考虑朴素做法，循环<br>$n$ 次，每次找到一个没有在序列答案序列中且入度为 $0$<br>的点，把它连出的边的每一个终点入度 $-1$<br>，然后加入答案。此做法时间复杂度易得为 $\Theta(V^2)$ 。\<br>考虑优化。首先建立一个队列，把图中入度为 $0$<br>的点入队。然后把队首弹出，放入答案序列，并且把该点连出的边的每一个终点入度<br>$-1$ ，同时把入度为 $0$<br>的终点加入队列，重复此过程直到队列为空。如果答案序列长度不足 $n$<br>,则证明该有向图有环。此做法的时间复杂度为 $\Theta(V+E)$ 。</p><h2 id="mathbf-Tarjan-算法"><a href="#mathbf-Tarjan-算法" class="headerlink" title="$\mathbf{Tarjan}$ 算法"></a>$\mathbf{Tarjan}$ 算法</h2><p>$Tarjan$<br>算法是有向图的终极算法，有向图中可用于求强连通分量，还能缩点。具体思路是利用<br>$dfs$ 序的性质，在 $dfs$ 回溯是进行求解。首先建立数组 $dfn[],<br>    low[]$ ，分别代表 $dfs$ 序和 $dfs$ 序中可以回溯到的最早位置。在<br>$dfs$ 的时候处理出两个数组，就可以利用 $dfs$<br>序的性质求解。这样每个点，每条边都仅访问一次，时间复杂度为 $\Theta(V+E)$<br>。</p><h3 id="求强连通分量"><a href="#求强连通分量" class="headerlink" title="求强连通分量"></a>求强连通分量</h3><p>显然，在 $dfs$<br>序中，如果子孙能有一条边连向祖先，那么从祖先到这个子孙之间的所有点都在一个强连通图中。当一个点能够回溯到的最早位置为自己，即<br>$dfn[u]=low[u]$<br>时，这个点以及可以回溯到它的最后子孙之间的点就处于一个强连通分量中。此时可以想到使用栈来处理。建立一个栈，<br>$dfs$<br>时将点压入其中，然后当回溯到一个点，找到强连通分量后就将这之间的点全部弹出，然后放入同一个强连通分量中。</p><h2 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h2><p>同上，将一个强连通分量缩成新图中的一个点即可。接下来按题目要求在 $DAG$<br>上操作。</p><h1 id="无向图算法"><a href="#无向图算法" class="headerlink" title="无向图算法"></a>无向图算法</h1><h2 id="mathbf-Tarjan-算法-1"><a href="#mathbf-Tarjan-算法-1" class="headerlink" title="$\mathbf{Tarjan}$ 算法"></a>$\mathbf{Tarjan}$ 算法</h2><p>你没有看错！又是它！无向图中， $Tarjan$<br>算法可以用来求双连通分量，割点，桥。思路和有向图差不多，时间复杂度也一致。</p><h3 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h3><p>割点指的是去掉这个点对图的连通性有影响。考虑一个点如果是割点，那么它的所有子孙能够回溯到的最早位置一定都是自己的子孙，即对于所有子孙<br>$v$ ,都有 $low[v]&gt;=dfn[u]$ 。</p><h3 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h3><p>与割点类似，桥指的是去掉这条边后对图的连通性有影响。同上理，如果一个点对于所有子孙<br>$v$ ,都有 $low[v]&gt;dfn[u]$ ，那么边 $e(u,v)$ 为桥。</p><h3 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h3><p>无向图中，没有割点的一个极大连通分量就是一个点双连通分量，求法与割点类似。</p><h3 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h3><p>同理，无向图中，没有桥的一个极大连通分量就是一个边双连通分量，求法与桥类似。</p><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>如果一个图中所有点可以被分成两个非空点集 $\mathbb{U}$ ， $\mathbb{V}$<br>，且 $\mathbb{U}\cap \mathbb{V}=\varnothing$<br>，其中同一属于点集中的点不互相连边，那么这个图就是二分图。\<br>任意两条边都没有公共顶点的一个边集称为二分图的一组匹配。包含边数最多的一组匹配称为二分图最大匹配。求解二分图最大匹配，可以用匈牙利算法。\<br>一组匹配 $\mathbb{E}$ ，对于任意一条边 $e$ ，若 $e\in \mathbb{E}$ 则称<br>$e$ 为匹配边，否则称 $e$<br>为非匹配边。所有匹配边的两个端点都称为匹配点，其余点称为非匹配点。\<br>匈牙利算法的思路是在图中寻找增广路，增广路是指的一条从非匹配点到非匹配点的路径，其中匹配边与非匹配边在路径上交替出现。增广路在对路径上所有边取反（匹配边变成非匹配边，非匹配边变成匹配边），可以使匹配边条数<br>$+1$ 。\<br>匈牙利算法寻找增广路的方法是依次尝试给每一个结点 $u\in \mathbb{U}$<br>寻找一个匹配的结点 $v\in \mathbb{V}$ ，其中 $v$ 满足以下条件之一：</p><ul><li>$v$ 是非匹配点。</li><li>$v$ 已经与 $u’$ 匹配，但 $u’$ 可以找到另一个点 $v’$ 与之匹配。\<br>对于每个点都要进行一次匹配，每次匹配的最坏情况是遍历所有的边，所以时间复杂度为<br>$\Theta(V\cdot E)$ 。</li></ul><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><p>一个网络指的是一张有向图<br>$\mathbf{G}=(\mathbb{V},\mathbb{E})$，每条边的权值称为边的容量。图中还有两个特殊结点<br>$s$ ， $t$ ，称为源点和汇点。定义流量 $f(u,v)$<br>为实数函数，且满足以下条件：\<br>  -对于每条边 $e(u,v)\in \mathbb{E}$，都有 $f(u,v)\leq w(u,v)$ 。\<br>  -取 $\forall x\in \mathbb{V},x\neq s,x\neq t$ ，都有<br>$\sum_{e(u,x)\in \mathbb{E}} f(u,x)=\sum_{e(x,v)\in \mathbb{E}} f(x,v)$<br>。\<br>  -对于任意流量 $f(u,v)$ ，都有 $f(u,v)=-f(v,u)$ 。\<br>对于一条边 $e(u,v)\in \mathbb{E}$ ， $w(u,v)-f(u,v)$<br>就是这条边的残量。一个网络中所有残量组成的新的网络称为残量网络。\<br>网络的流量就是指的 $f(s,t)$ 。一个网络最大的合法流量称为网络最大流。</p><h2 id="mathbf-EK-算法"><a href="#mathbf-EK-算法" class="headerlink" title="$\mathbf{EK}$ 算法"></a>$\mathbf{EK}$ 算法</h2><h2 id="思路简介-6"><a href="#思路简介-6" class="headerlink" title="思路简介"></a>思路简介</h2><p>求解网络最大流，一种方法是用 $EK$ 算法求解。 $EK$<br>算法的思路与匈牙利算法差不多，也是通过寻找增广路。此时增广路的定义为一条残量均大于<br>$0$ 的路径。具体操作为从 $s$ 开始向外 $bfs$ 只走残量大于 $0$<br>的边，直到找到 $t$ 为止。然后计算最小残量 $minf$ ，把增广路上的边边权<br>$-minf$ ，然后把反向边边权 $+minf$ 直到找不到增广路。此算法时间复杂度<br>$\Theta(V\cdot E^2)$</p><h3 id="算法优劣-6"><a href="#算法优劣-6" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>此算法虽然时间复杂度较高，但很难跑满。一般在稀疏图中跑网络流会用 $EK$<br>算法。</p><h2 id="mathbf-Dinic-算法"><a href="#mathbf-Dinic-算法" class="headerlink" title="$\mathbf{Dinic}$ 算法"></a>$\mathbf{Dinic}$ 算法</h2><h3 id="思路简介-7"><a href="#思路简介-7" class="headerlink" title="思路简介"></a>思路简介</h3><p>更多的时候，求解网络流会用 $Dinic$ 算法。 $Dinic$ 算法的主要特点是对图用<br>$bfs$ 进行分层，再用 $dfs$<br>寻找增广路，每次寻找增广路的时候只往下一层找，保证了 $dfs$<br>的迭代次数不多。同时还可以加入各种剪枝。朴素的 $Dinic$ 算法时间复杂度为<br>$\Theta(V^2\cdot E)$ 。</p><h3 id="算法优劣-7"><a href="#算法优劣-7" class="headerlink" title="算法优劣"></a>算法优劣</h3><p>乍一看，此算法时间复杂度和 $EK$<br>算法差不多，但实际应用中一般处理的都是稠密图，边数远大于点数，此时用<br>$Dinic$ 是一个不错的选择。</p><h1 id="其他建图问题"><a href="#其他建图问题" class="headerlink" title="其他建图问题"></a>其他建图问题</h1><h2 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h2><p>一个由 $n$ 个变量和 $m$ 个形如 $a_i-a_j\leq k$<br>的约束条件组成的系统称为差分约束系统。可以将约束条件转化为形如<br>$dis[i]\leq dis[j]+w(i,j)$ 的图论条件。\<br>显而易见，可以转化为图论问题。对于每个条件 $i+j\leq k$ ，建立一条边<br>$w(i,j)=k$ 。新建虚拟源点，源点连向所有点的边权为 $0$<br>.在图上跑最短路，最终 $dis[]$ 即为一组可行解。</p><h2 id="mathbf-2-sat-问题"><a href="#mathbf-2-sat-问题" class="headerlink" title="$\mathbf{2-sat}$ 问题"></a>$\mathbf{2-sat}$ 问题</h2><p>$2-sat$ 问题是一种特殊的逻辑判断问题。给定 $n$ 个变量和 $m$<br>个限制条件，每个变量有一个值 $val_i\in\left\{0,1\right\}$<br>，且限制条件均为形如\<br>$(\neg)val_i(opt)(\neg)val_j$<br>等对两个变量的值的限制。由于每个变量都只有两个状态，所以考虑建图是把一个变量<br>$val_i$ 拆成两个点 $i$ ， $i’$ ，分别表示这个点取 $0$ 还是取 $1$<br>，然后考虑连边。每条边 $e(u,v)$ 表示如果点 $u$ 选择的那么就必须选 $v$<br>。最后可以发现，如果选择了一个点，那么也要选择和它在同一个强连通分量里的点。所以我们可以通过判断对于每个变量<br>$val_i$ ， $i$ 和 $i’$ 是否在同一个强连通分量里。如果是，那么这个<br>$2-sat$ 问题就无解，否则就可以输出 $i$ 和 $i’$<br>中拓扑序较大的一个形成一组解。连边的方式主要有以下几种：</p><ul><li>$val_i\oplus val_j=1$ 即 $i$ ， $j$<br>必须选一个但不能同时选。连边方式为 $i-&gt;j’,j-&gt;i’$ 。</li><li>$val_i\oplus val_j=0$ 即 $i$ ， $j$ 要么都选要么都不选。连边方式为<br>$i-&gt;j,j-&gt;i,i’-&gt;j’,j’-&gt;i’$ 。</li><li>$val_i|val_j=1$ 即 $i$ ， $j$ 至少选一个。连边方式为 $i’-&gt;j,j’-&gt;i$<br>。</li><li>$i$ 即 $i$ 必须选。连边方式为 $i’-&gt;i$ 。</li><li>$\neg i$ 即 $i$ 不能选。连边方式为 $i-&gt;i’$ 。\<br>此方法每条边都至多经过一次，故时间复杂度为 $\Theta(E)$ 。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论总结</title>
      <link href="/2019/08/21/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数论"><a href="#基础数论" class="headerlink" title="基础数论"></a>基础数论</h1><h2 id="扩展欧几里得算法-mathbf-exgcd"><a href="#扩展欧几里得算法-mathbf-exgcd" class="headerlink" title="扩展欧几里得算法 $\mathbf{exgcd}$"></a>扩展欧几里得算法 $\mathbf{exgcd}$</h2><p>首先介绍一下贝祖定理。若 $a,b$ 是整数，那么 $a\cdot x+b\cdot y=\gcd(a,b)$一定有解。如果需要判断 $a\cdot x+b\cdot y=c$ 有没有解，可以直接判断 $c|\gcd(a,b)$可以用欧几里得算法求 $\gcd(a,b)$。但如果需要求出一组解，我们就必须对欧几里得算法进行扩展。考虑边界，欧几里得算法结束的条件是$b=0,a=\gcd(a,b)$ ，此时可以得到一组解 $x=1,y=0$。再考虑回溯是处理，每层我们都已知 $\gcd(b,a\bmod b)$ ，并且有一组解$x1,y1$ 使得 $b\cdot x1+(a\bmod b)\cdot y1=gcd$ 。我们知道，$a\bmod b=a-\left\lfloor\frac{a}{b}\right\rfloor\cdot b$ 带入化简得$a\cdot y1+b\cdot (x1-\left\lfloor\frac{a}{b}\right\rfloor\cdot y1)=gcd$ 可以发现，$x=y1,y=x1-\left\lfloor\frac{a}{b}\right\rfloor\cdot y1$可以递归求解。时间复杂度为 $\Theta(\log_2 \max(a,b))$</p><h2 id="乘法逆元-mathbf-inv"><a href="#乘法逆元-mathbf-inv" class="headerlink" title="乘法逆元 $\mathbf{inv}$"></a>乘法逆元 $\mathbf{inv}$</h2><p>对于两个数 $a,p$ ，若有 $\gcd(a,p)=1$ ，那么一定<br>$\exists b\quad  a\cdot b\equiv 1\pmod{p}$ 。此时称 $b$ 为 $a$ 在模 $p$<br>意义下的逆元，记做 $a^{-1}=b$ 。计算乘法逆元，有多种方法。</p><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>费马小定理的内容是若 $\gcd(a,p)=1$ 则有 $a^p\equiv a\pmod{p}$<br>将其变形，可得 $a\cdot a^{p-2}\equiv 1\pmod{p}$ 所以可以得到<br>$a^{-1}=a^{p-2}$ 可用快速幂求出。</p><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p>由定义可变形得到 $a\cdot a^{-1}=k\cdot p+1$ 移项可得 $a\cdot a^{-1}-k\cdot p=1$<br>与扩展欧几里得的标准形式一致。</p><h2 id="线性递推计算"><a href="#线性递推计算" class="headerlink" title="线性递推计算"></a>线性递推计算</h2><p>首先简单计算可得 $1^{-1}=1$ 。考虑对于 $\forall i$ ，如果 $i-1$<br>的逆元已经求出，可以线性求出。令 $p=k\cdot i+r$ ，则<br>$k=\left\lfloor\frac{p}{i}\right\rfloor,r=p \bmod i$ ，可得<br>$k\cdot i+r\equiv 0\pmod{p}$ 经过代入整理得<br>$i^{-1}\equiv-\left\lfloor\frac{p}{i}\right\rfloor\cdot (p \bmod i)^{-1}\pmod{p}$<br>得出线性递推式。时间复杂度为 $\Theta(n)$ 。</p><h2 id="阶乘递推计算"><a href="#阶乘递推计算" class="headerlink" title="阶乘递推计算"></a>阶乘递推计算</h2><p>由逆元的定义可得 $n!^{-1}\equiv \frac{1}{n!}\pmod{p}$ 左右同乘 $n$<br>，化简得 $n!^{-1}\cdot n\equiv (n-1)!^{-1}\pmod{p}$ 得到递推式<br>$n!^{-1}\equiv \frac{(n-1)!^{-1}}{n}\pmod{p}$</p><h2 id="中国剩余定理-mathbf-crt"><a href="#中国剩余定理-mathbf-crt" class="headerlink" title="中国剩余定理 $\mathbf{crt}$"></a>中国剩余定理 $\mathbf{crt}$</h2><p> 中国剩余定理主要是为了解一种特殊的同余方程组。形如 $\begin{cases}<br>        x\equiv a_1\pmod{p_1}\\<br>        x\equiv a_2\pmod{p_2}\\<br>        \cdots \\<br>        x\equiv a_n\pmod{p_n}<br>    \end{cases}$ 的式子。同时，式子满足 $\forall i,\forall j,i\neq j$<br>都有 $\gcd(p_i,p_j)=1$ 。考虑暴力做法，可以得到答案为下式<br>$k_1\cdot \frac{p_1\cdot p_2\cdot \cdots \cdot p_n}{p_1}+k_2\cdot \frac{p_1\cdot p_2\cdot \cdots \cdot p_n}{p_2}+\cdots +k_n\cdot \frac{p_1\cdot p_2\cdot \cdots \cdot p_n}{p_n}$<br>且 $\forall i,i\leq n$ 满足<br>$k_i\cdot \frac{p_1\cdot p_2\cdot \cdots \cdot p_n}{p_i}\bmod p_i=a_i$ 。设<br>$m_i=\frac{p_1\cdot p_2\cdot \cdots \cdot p_n}{p_i}$ 那么 $k_i\cdot m_i\equiv a_i\pmod{p_i}$<br>此时可以用逆元来求解 $k_i$ 最后求出答案。时间复杂度为 $\Theta(1)$ 。</p><h2 id="扩展中国剩余定理-mathbf-excrt"><a href="#扩展中国剩余定理-mathbf-excrt" class="headerlink" title="扩展中国剩余定理 $\mathbf{excrt}$"></a>扩展中国剩余定理 $\mathbf{excrt}$</h2><p>如果中国剩余定理中的 $p_i$ 不满足 $\forall i,\forall j,i\neq j$ 都有<br>$\gcd(p_i,p_j)=1$ ，就不能使用中国剩余定理求解。考虑两两合并，下面方程组<br>$\begin{cases}<br>        x\equiv a_1\pmod{p_1}\\<br>        x\equiv a_2\pmod{p_2}\\<br>    \end{cases}$ 可以化成 $p_1\cdot y+a_i=p_2\cdot z+a_2$<br>这个东西可以用扩展欧几里得合并。每次两两合并得出答案。时间复杂度<br>$\Theta(n\cdot \log_2 n)$ 。</p><h2 id="大步小步算法-mathbf-BSGS"><a href="#大步小步算法-mathbf-BSGS" class="headerlink" title="大步小步算法 $\mathbf{BSGS}$"></a>大步小步算法 $\mathbf{BSGS}$</h2><p>$BSGS$ 算法的目的是求解形如 $a^b\equiv c\pmod{p}$ ，其中 $\gcd(a,p)=1$<br>的同余方程。首先将 $b$ 写成 $k\cdot x+r$ 的形式。代入原式，得<br>$a^{k\cdot x}\equiv c\cdot a^r\pmod{p}$ 首先求出 $b$ 在 $[0,x-1]$<br>范围内右式的值，并储存。然后枚举所有可能的 $a$<br>，计算出左式的值，然后查询。时间复杂度为 $\Theta(\max(x,p/x))$ 可得<br>$x=\sqrt{p}$ 是最优。时间复杂度 $\Theta(\sqrt{p})$ 。</p><h2 id="扩展大步小步算法-mathbf-exBSGS"><a href="#扩展大步小步算法-mathbf-exBSGS" class="headerlink" title="扩展大步小步算法 $\mathbf{exBSGS}$"></a>扩展大步小步算法 $\mathbf{exBSGS}$</h2><p>如果在求解形如 $a^b\equiv c\pmod{p}$ 的同余方程时 $\gcd(a,p)\neq 1$<br>我们不能用 $BSGS$<br>来求。这个时候我们就必须换一种方法。首先把方程改写为等式 $a^b+k\cdot p=c$<br>发现此时的 $c$ 必须要是 $\gcd(a,p)$<br>的倍数，否则无解。不断在等式两边同时除以 $gcd(a,p)$ 直到<br>$\gcd(a,\frac{c}{\gcd(a,p)})=1$ ，此时式子满足 $BSGS$ 的求解条件，用<br>$BSGS$ 求解。</p><h2 id="卢卡斯定理-mathbf-Lucas"><a href="#卢卡斯定理-mathbf-Lucas" class="headerlink" title="卢卡斯定理 $\mathbf{Lucas}$"></a>卢卡斯定理 $\mathbf{Lucas}$</h2><p>$Lucas$ 定理用于求 $C_n^m\bmod p$ 的值。由二项式定理可知 $C_n^m$ 即为<br>$(x+1)^n$ 中 $x^m$ 的系数。对于式子<br>$(x+1)^{n_0}\cdot (x^p+1)^{n_1}\cdot (x^{p^2}+1)^{n_2}\cdot \cdots \cdot (x^{p^n}+1)^{n_k}\pmod{p}$<br>$C_{n_0}^{m_0}$ 即为 $(x+1)^n_0$ 中 $x^{b_0}$ 的系数， $C_{n_k}^{m_k}$<br>即为 $(x^{p^k}+1)^{n_k}$ 中 $x^{b_k\cdot p^k}$ 的系数，同理可得其余。因为<br>$\prod_{i=0}^k C_{n_i}^{m_i}\cdot x^{m_i\cdot p^i}=C_n^m\cdot x^m$ 所以可得<br>$C_n^m=\prod_{i=0}^k C_{n_i}^{m_i}$ 时间复杂度为 $\Theta(p\cdot \log_p n)$<br>。</p><h1 id="素数合数"><a href="#素数合数" class="headerlink" title="素数合数"></a>素数合数</h1><h2 id="枚举判断"><a href="#枚举判断" class="headerlink" title="枚举判断"></a>枚举判断</h2><p>思路很简单，枚举 $[2,\left\lfloor\sqrt{n}\right\rfloor]$<br>范围内所有的数，判断是否是 $n$ 的因数。时间复杂度为 $\Theta(\sqrt{n})$<br>。</p><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>埃氏筛的思想很简单，从 $2$<br>开始向后扫描，如果这个数是不是合数，那么把它的倍数全部标记为合数。时间复杂度为<br>$\Theta(n\cdot log_2 n)$ 。</p><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>考虑优化埃氏筛。发现每个数都被它所有的质因数打上标记。可以通过使每个数都只被它最小的质因子筛去。将每个数的质数倍的数标记为合数（无论其本身是不是合数），这样可以保证每个数只会被自己最小的质因子筛去。</p><h2 id="mathbf-Miller-Rabin"><a href="#mathbf-Miller-Rabin" class="headerlink" title="$\mathbf{Miller-Rabin}$"></a>$\mathbf{Miller-Rabin}$</h2><p>当我们需要判断一个数是否是质数时，我们需要 $\Theta(\sqrt{n})$<br>的时间判断。当这个数较大的时候，我们就不能使用枚举。考虑使用费马小定理。但当<br>$\gcd(a,b)=1$ 且 $a^p\equiv a\pmod{p}$ 时，不能得出 $p$<br>是质数的结论。这个时候我们引入二次探测。如果 $p$ 为质数，且 $0&lt;x&lt;p$<br>则方程 $x^2\equiv 1\pmod{p}$ 的解为 $x=1$ 或 $x=p-1$ 。 $Miller-Rabin$<br>判断 $n$ 是否为质数的流程为：首先判断 $0,1,2$<br>和偶数。先随机取一个较小的质数 $p$ ，设 $s,t$ 满足 $2^s\cdot t=n-1$ 。算出<br>$p^t$ ，进行 $s$<br>次二次探测，每次进行平方，最后用费马小定理判断。多次取不同的 $p$<br>进行判断，如果全部通过，那么 $n$ 大概率是质数。算法时间复杂度为<br>$\Theta(p\cdot \log_2^3 n)$</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p>数论函数是指这样一类函数：其定义域是正整数，值域是一个数集。定义两个数论函数的加法，为逐项相加，即<br>$(\mathbf{f+g})(n)=\mathbf{f}(n)+\mathbf{g}(n)$<br>。数乘，即一个数乘到一个数论函数上，定义为这个数和每一项都相乘，即<br>$(x\cdot \mathbf{f})(n)=x\cdot \mathbf{f}(n)$ 。</p><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>狄利克雷卷积是数论函数的一个运算。设 $\mathbf{h=f\times g}$ ，那么有<br>$\mathbf{h}(n)=\sum_{i|n} \mathbf{f}(i)\cdot \mathbf{g}(\frac{n}{i})$<br>它拥有以下性质：</p><ul><li>$\mathbf{f\times g=g\times f}$</li><li>$\mathbf{(f\times g)\times h=f\times (g\times h)}$</li><li>$\mathbf{(f+g)\times h=f\times h+g\times h}$</li><li>$(x\times \mathbf{f})\times \mathbf{g}=x\times (\mathbf{f\times g})$</li><li>$\epsilon \times \mathbf{f}=\mathbf{f}$</li></ul><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数 $\phi(n)$ 是小于或等于 $n$ 的正整数中与 $n$<br>互质的数的数目。通式为 $\varphi(x)=x\cdot \prod_{i=1}^n (1-\frac{1}{p_i})$<br>其中 $p_1,p_2\cdots p_n$ 为 $x$<br>的质因子。处理可以用定义求解，也可以用埃氏筛和线性筛求解。</p><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><p>莫比乌斯函数的通式为 $\mu (n)=<br>    \begin{cases}<br>        1\quad n=1\\<br>        (-1)^k\quad p_1\times p_2\times \cdots \times p_n\\<br>        0\quad else<br>    \end{cases}$ 莫比乌斯函数主要用于容斥原理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈KMP</title>
      <link href="/2019/07/14/%E6%B5%85%E8%B0%88KMP/"/>
      <url>/2019/07/14/%E6%B5%85%E8%B0%88KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-mathbf-KMP"><a href="#什么是-mathbf-KMP" class="headerlink" title="什么是 $\mathbf{KMP}$"></a>什么是 $\mathbf{KMP}$</h1><p>$KMP$ 算法是一种改进的字符串匹配算法，由$D.E.$ <strong>K</strong> $nuth$，$J.H.$ <strong>M</strong> $orris$和$V.R.$ <strong>P</strong> $ratt$提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称 $KMP$ 算法）。 $KMP$ 算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个 $next()$ 函数，函数本身包含了模式串的局部匹配信息。时间复杂度 $\Theta(m+n)$ 。  </p><p align="right">（From 百度百科）</p><h1 id="mathbf-KMP-算法的思想"><a href="#mathbf-KMP-算法的思想" class="headerlink" title="$\mathbf{KMP}$ 算法的思想"></a>$\mathbf{KMP}$ 算法的思想</h1><p>首先我们考虑朴素的字符串匹配。通过两个指针分别指向文本串和模式串，如果失配，那么文本串指针会指向开始匹配的下一位，而模式串的指针则会指向串首。如下图：</p><p><img src="/2019/07/14/浅谈KMP/kmp_1.png" alt></p><p>但是我们可以发现，我们在第一次失配前已经知道文本串的前 $5$ 个字符，那么我们就可以找到一种更优的失配转移，如下图：</p><p><img src="/2019/07/14/浅谈KMP/kmp_2.png" alt></p><p>我们可以发现，我们可以找到模式串下标为 $n$ 时失配的更优失配转移，当且仅当模式串下标为 $[0,n]$ 的子串中的前缀等于后缀，如下图：</p><p><img src="/2019/07/14/浅谈KMP/kmp_3.png" alt></p><p>显然，子串中最长前缀等于最长后缀时，可以找到最优失配转移。由此得到 $KMP$ 算法的思路：预处理模式串，得到失配数组（ $fail$ 数组），再进行匹配。</p><h1 id="如何预处理出-mathbf-fail-数组"><a href="#如何预处理出-mathbf-fail-数组" class="headerlink" title="如何预处理出 $\mathbf{fail}$ 数组"></a>如何预处理出 $\mathbf{fail}$ 数组</h1><p>从上文可以看出，我们需要找到最长的前缀等于后缀。建立数组 $fail[]$ 储存失配后2指针应跳转的位置。不难想到， $fail[0]=fail[1]=0$ 因为这两个位置失配后必须回到字符串起点。接下来我们可以不停的对当前失配的位置回跳 $fail$ 指针，直到匹配或跳到字符串首。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void get_fail(char s[])</span><br><span class="line">&#123;</span><br><span class="line">fail[0]=0;</span><br><span class="line">fail[1]=0;</span><br><span class="line">for(register int i=1;i&lt;strlen(s);++i)</span><br><span class="line">&#123;</span><br><span class="line">int t=fail[i];</span><br><span class="line"></span><br><span class="line">while(t&amp;&amp;s[t]!=s[i]) t=fail[t];</span><br><span class="line">if(s[t]==s[i]) fail[i+1]=t+1;</span><br><span class="line">else fail[i+1]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同理，我们在 $kmp$ 的时候对两个字符串进行这样的操作。对比来看， $get\text{_}fail$ 操作其实就是模式串和文本串都是模式串的 $kmp$ 。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void kmp(char s[],char t[])</span><br><span class="line">&#123;</span><br><span class="line">int now=0,len=strlen(t);</span><br><span class="line"></span><br><span class="line">get_fail(t);</span><br><span class="line">for(register int i=0;i&lt;strlen(s);++i)</span><br><span class="line">&#123;</span><br><span class="line">while(now&amp;&amp;s[i]!=t[now]) now=fail[now];</span><br><span class="line">if(s[i]==t[now]) now++;</span><br><span class="line">if(now==len)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i-len+1);</span><br><span class="line">now=fail[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>$KMP$ 算法具有一种“最优历史处理”的性质，而这种性质也是基于 $KMP$ 的核心思想的。考虑前缀与后缀的关系使得其在匹配的时候不会反反复复地找。最后放上模板和 $std$ : <a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">P3375 【模板】KMP字符串匹配</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string a,b;</span><br><span class="line">int fail[1000005];</span><br><span class="line"></span><br><span class="line">void get_fail(string s)</span><br><span class="line">&#123;</span><br><span class="line">fail[0]=0;</span><br><span class="line">fail[1]=0;</span><br><span class="line">for(unsigned int i=1;i&lt;s.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">int t=fail[i];</span><br><span class="line"></span><br><span class="line">while(t&amp;&amp;s.at(t)!=s.at(i)) t=fail[t];</span><br><span class="line">if(s.at(t)==s.at(i)) fail[i+1]=t+1;</span><br><span class="line">else fail[i+1]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void kmp(string s1,string s2)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int now=0;</span><br><span class="line"></span><br><span class="line">get_fail(s2);</span><br><span class="line">for(unsigned int i=0;i&lt;s1.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">while(now&amp;&amp;s1.at(i)!=s2.at(now)) now=fail[now];</span><br><span class="line">if(s1.at(i)==s2.at(now)) now++;</span><br><span class="line">if(now==s2.length())</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i-s2.length()+1);</span><br><span class="line">now=fail[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">a=&quot; &quot;+a;</span><br><span class="line">kmp(a,b);</span><br><span class="line"></span><br><span class="line">for(unsigned int i=1;i&lt;=b.length();i++) printf(&quot;%d &quot;,fail[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> String Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Splay</title>
      <link href="/2019/07/10/%E6%B5%85%E8%B0%88Splay/"/>
      <url>/2019/07/10/%E6%B5%85%E8%B0%88Splay/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-mathbf-Splay"><a href="#什么是-mathbf-Splay" class="headerlink" title="什么是 $\mathbf{Splay}$"></a>什么是 $\mathbf{Splay}$</h1><p><a href="https://baike.baidu.com/item/%E4%BC%B8%E5%B1%95%E6%A0%91/7003945?fr=aladdin" target="_blank" rel="noopener">伸展树</a>（$Splay\quad Tree$），也叫分裂树，是一种<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079" target="_blank" rel="noopener">二叉排序树</a>，它能在 $\Theta(log_2 n)$ 内完成插入、查找和删除操作。它由丹尼尔·斯立特（ $Daniel\quad Sleator$ ） 和 罗伯特·恩卓·塔扬（ $Robert\quad Endre$ <strong>Tarjan</strong> <del>又是他</del>）在 $1985$ 年发明的。<br>假设想要对一个二叉排序树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。 $Splay\quad tree$ 应运而生。 $Splay\quad tree$ 是一种自调整形式的二叉查找树，它会沿着从某个结点到树根之间的路径，通过一系列的旋转把这个结点搬移到树根去。  </p><p align="right">（From 百度百科）</p><p>因为 $Splay$ 是一颗二叉排序树，所以它的每一个结点都应该满足如下性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于这个结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于或等于这个结点的值。</li></ul><p>我们知道，在对二叉树进行中序遍历时，会先遍历左子树，然后是自身，最后才是右子树。所以一颗二叉排序树的中序遍历是不严格单调递增的。我们在进行重构树时，也需要保证中序遍历不变。</p><h1 id="mathbf-Splay-可以做什么"><a href="#mathbf-Splay-可以做什么" class="headerlink" title="$\mathbf{Splay}$ 可以做什么"></a>$\mathbf{Splay}$ 可以做什么</h1><ul><li>维护一个区间（<del>废话</del>）。</li><li>支持区间翻转。</li><li>支持求一个结点的前驱和后继。</li><li>支持求一个结点的排名。</li><li>支持求第k大。</li></ul><h1 id="mathbf-Splay-需要维护的内容"><a href="#mathbf-Splay-需要维护的内容" class="headerlink" title="$\mathbf{Splay}$ 需要维护的内容"></a>$\mathbf{Splay}$ 需要维护的内容</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int val[N];//当前结点的值</span><br><span class="line">int cnt[N];//有多少个重复结点</span><br><span class="line">int pre[N];//当前结点的父结点</span><br><span class="line">int siz[N];//以当前结点为根的子树大小</span><br><span class="line">int son[N][2];//当前结点的子结点([0]为左儿子，[1]为右儿子)</span><br><span class="line">bool rev[N];//是否翻转</span><br></pre></td></tr></table></figure><h1 id="mathbf-Splay-支持的操作"><a href="#mathbf-Splay-支持的操作" class="headerlink" title="$\mathbf{Splay}$ 支持的操作"></a>$\mathbf{Splay}$ 支持的操作</h1><h2 id="mathbf-get-dir-操作"><a href="#mathbf-get-dir-操作" class="headerlink" title="$\mathbf{get_dir}$ 操作"></a>$\mathbf{get_dir}$ 操作</h2><p>这个操作的目的是确定一个结点是父结点的左儿子还是右儿子，返回值为 $0$ 或 $1$ 。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline int get_dir(int x)</span><br><span class="line">&#123;</span><br><span class="line">return son[pre[x]][1]==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-push-up-操作"><a href="#mathbf-push-up-操作" class="headerlink" title="$\mathbf{push_up}$ 操作"></a>$\mathbf{push_up}$ 操作</h2><p>这个操作的目的是更新子树大小。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void push_up(int x)</span><br><span class="line">&#123;</span><br><span class="line">siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-rotate-操作"><a href="#mathbf-rotate-操作" class="headerlink" title="$\mathbf{rotate} 操作"></a>$\mathbf{rotate} 操作</h2><p>核心操作。 $Splay$ 通过旋转操作来保持平衡。<br>每次旋转有两种不同情况的旋转，分别是当前结点是父亲结点的左儿子和右儿子。</p><p>如果当前结点是父亲的左儿子，如下图，我们要把红点向上一层旋转：</p><p><img src="/2019/07/10/浅谈Splay/splay_1.png" alt></p><p>为了方便，我们不妨令这颗树的中序遍历为 $1-2-3-4-5-6-7$ 。如下图，2号点就是我们要旋转的点：</p><p><img src="/2019/07/10/浅谈Splay/splay_2.png" alt></p><p>我们可以清楚的看出 $rotate$ 的变化规律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">son[4][0]=3;</span><br><span class="line">pre[3]=4;//目标结点父亲的左儿子-&gt;目标结点的右儿子</span><br><span class="line">son[6][0]=2;</span><br><span class="line">pre[2]=6;//目标结点爷爷的（左/右）儿子-&gt;目标结点</span><br><span class="line">son[2][1]=4;</span><br><span class="line">pre[4]=2;//目标结点的右儿子-&gt;目标结点的父亲</span><br></pre></td></tr></table></figure></p><p>同理，我们可以看出当前结点是父亲的右儿子时的规律（图中 $6$ 号结点是目标结点）：</p><p><img src="/2019/07/10/浅谈Splay/splay_3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">son[4][1]=5;</span><br><span class="line">pre[5]=4;//目标结点父亲的右儿子-&gt;目标结点的左儿子</span><br><span class="line">son[2][1]=6;</span><br><span class="line">pre[6]=2;//目标结点爷爷的（左/右）儿子-&gt;目标结点</span><br><span class="line">son[6][0]=4;</span><br><span class="line">pre[4]=6;//目标结点的左儿子-&gt;目标结点的父亲</span><br></pre></td></tr></table></figure><p>归纳一下，可以得出以下步骤：</p><ul><li>求出目标结点位于父亲结点的方向，并作为基本方向；</li><li>目标结点父亲的同向儿子-&gt;目标结点的异向儿子；</li><li>目标结点爷爷的（左/右）儿子-&gt;目标结点；</li><li>目标结点的异向儿子-&gt;目标结点的父亲；</li></ul><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inline void rotate(int x)</span><br><span class="line">&#123;</span><br><span class="line">int f=pre[x],g=pre[f],d=get_dir(x),s=son[x][d^1];</span><br><span class="line"></span><br><span class="line">son[f][d]=s;</span><br><span class="line">pre[s]=f;</span><br><span class="line">son[g][get_dir(f)]=x;</span><br><span class="line">pre[x]=g;</span><br><span class="line">son[x][d^1]=f;</span><br><span class="line">pre[f]=x;</span><br><span class="line">push_up(f);</span><br><span class="line">push_up(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-splay-操作"><a href="#mathbf-splay-操作" class="headerlink" title="$\mathbf{splay}$ 操作"></a>$\mathbf{splay}$ 操作</h2><p>这个操作的目的是将一个结点一直旋转至目标结点的儿子，如果目标结点为 $0$ ，则表示旋转至根结点。<br>其实只需要每次进行旋转后判断父亲是不是目标结点，如果爷爷，父亲与当前结点“三点一线”，我们就要先旋转父结点，再旋转当前结点，使这颗 $Splay$ 更平衡（<del>这是一个很玄学的问题</del>）。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void splay(int x,int tar=0)</span><br><span class="line">&#123;</span><br><span class="line">while(pre[x]!=tar)</span><br><span class="line">&#123;</span><br><span class="line">int f=pre[x],g=pre[f];</span><br><span class="line"></span><br><span class="line">if(g!=tar)</span><br><span class="line">&#123;</span><br><span class="line">if(get_dir(x)==get_dir(f)) rotate(f);</span><br><span class="line">else rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">if(!tar) root=x;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-find-操作"><a href="#mathbf-find-操作" class="headerlink" title="$\mathbf{find}$ 操作"></a>$\mathbf{find}$ 操作</h2><p>这是一个辅助操作，目的是把最大的小于等于指定值的结点（如果有这个值，则返回这个值，否则返回最大的小于这个值的结点） $splay$ 到根结点。<br>操作很简单，只需要在每个结点处判断当前结点值是否小于指定值，再决定向左或向右,最后把找到的值 $splay$ 上来。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void find(int v)</span><br><span class="line">&#123;</span><br><span class="line">int x=root;</span><br><span class="line"></span><br><span class="line">if(!x) return;</span><br><span class="line">while(son[x][v&gt;val[x]]&amp;&amp;val[x]!=v)</span><br><span class="line">&#123;</span><br><span class="line">x=son[x][v&gt;val[x]];</span><br><span class="line">&#125;</span><br><span class="line">splay(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-insert-操作"><a href="#mathbf-insert-操作" class="headerlink" title="$\mathbf{insert}$ 操作"></a>$\mathbf{insert}$ 操作</h2><p>这个操作的目的是向 $Splay$ 里插入一个值。<br>和上一个操作类似，也是 需要在每个结点处判断当前结点值是否小于指定值，再决定向左或向右，如果结点存在则直接自增 $cnt$ 的值。否则新建结点并与父结点连边。<br>因为新建结点时可能会拉出一条链，为了保持 $Splay$ 的平衡，我们需要将该结点 $splay$ 到根。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void insert(int v)</span><br><span class="line">&#123;</span><br><span class="line">int x=root,f=0;</span><br><span class="line"></span><br><span class="line">while(x&amp;&amp;val[x]!=v)</span><br><span class="line">&#123;</span><br><span class="line">f=x;</span><br><span class="line">x=son[x][v&gt;val[x]];</span><br><span class="line">&#125;</span><br><span class="line">if(x) ++cnt[x];</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">x=(++ncnt);</span><br><span class="line">if(f) son[f][v&gt;val[f]]=x;</span><br><span class="line">val[x]=v;</span><br><span class="line">cnt[x]=1;</span><br><span class="line">pre[x]=f;</span><br><span class="line">siz[x]=1;</span><br><span class="line">son[x][0]=0;</span><br><span class="line">son[x][1]=0;</span><br><span class="line">&#125;</span><br><span class="line">splay(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-kth-操作"><a href="#mathbf-kth-操作" class="headerlink" title="$\mathbf{kth}$ 操作"></a>$\mathbf{kth}$ 操作</h2><p>显然，这个操作是求第 $k$ 大的数。<br>同样是从根结点开始向下搜，每次需要判断 $k$ 与左子树大小，与（左子树大小 $+$ 该结点 $cnt$ ）的大小关系，再决定向左或向右，或是返回这个结点。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int kth(int ord)</span><br><span class="line">&#123;</span><br><span class="line">int x=root;</span><br><span class="line"></span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">if(son[x][0]&amp;&amp;ord&lt;=siz[son[x][0]]) x=son[x][0];</span><br><span class="line">else if(ord&gt;siz[son[x][0]]+cnt[x])</span><br><span class="line">&#123;</span><br><span class="line">ord-=(siz[son[x][0]]+cnt[x]);</span><br><span class="line">x=son[x][1];</span><br><span class="line">&#125;</span><br><span class="line">else return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-rank-操作"><a href="#mathbf-rank-操作" class="headerlink" title="$\mathbf{rank}$ 操作"></a>$\mathbf{rank}$ 操作</h2><p>返回指定值的排名。<br>只需要把这个值转到根，再返回根结点左子树大小即可。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int rank(int v)</span><br><span class="line">&#123;</span><br><span class="line">find(v);</span><br><span class="line">return siz[son[root][0]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="prev-操作"><a href="#prev-操作" class="headerlink" title="prev 操作"></a>prev 操作</h2><p>求指定值的前驱（比它小的数中最大的）。<br>只需要找到左子树中最右边的那一个，返回即可。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int prev(int v)</span><br><span class="line">&#123;</span><br><span class="line">int u;</span><br><span class="line"></span><br><span class="line">find(v);</span><br><span class="line">u=son[root][0];</span><br><span class="line">while(son[u][1]) u=son[u][1];</span><br><span class="line"></span><br><span class="line">return u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-succ-操作"><a href="#mathbf-succ-操作" class="headerlink" title="$\mathbf{succ}$ 操作"></a>$\mathbf{succ}$ 操作</h2><p>求指定值的后继（比它大的数中最小的）。<br>同理，只需要找到右子树中最左边的那一个，返回即可。</p><p>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int succ(int v)</span><br><span class="line">&#123;</span><br><span class="line">int u;</span><br><span class="line"></span><br><span class="line">find(v);</span><br><span class="line">u=son[root][1];</span><br><span class="line">while(son[u][0]) u=son[u][0];</span><br><span class="line"></span><br><span class="line">return u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mathbf-remove-操作"><a href="#mathbf-remove-操作" class="headerlink" title="$\mathbf{remove}$ 操作"></a>$\mathbf{remove}$ 操作</h2><p>删除指定值。<br>如图，可以看出，如果把 $prev(x)\quad splay$ 到根结点，把 $succ(x)\quad splay$ 到 $prev(x)$ 的右儿子，那么 $succ(x)$ 的左儿子只会有目标结点一个结点，删除方法显而易见。</p><p><img src="/2019/07/10/浅谈Splay/splay_4.png" alt></p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void remove(int v)</span><br><span class="line">&#123;</span><br><span class="line">int p=prev(v),s=succ(v),tar;</span><br><span class="line"></span><br><span class="line">splay(p);</span><br><span class="line">splay(s,p);</span><br><span class="line">tar=son[p][0];</span><br><span class="line">if(cnt[tar]&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">--cnt[tar];</span><br><span class="line">splay(tar);</span><br><span class="line">&#125;</span><br><span class="line">else son[p][0]=0;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-reverse-操作"><a href="#mathbf-reverse-操作" class="headerlink" title="$\mathbf{reverse}$ 操作"></a>$\mathbf{reverse}$ 操作</h2><p>区间翻转， $Splay$ 的标准操作之一。<br>和线段树区间加一样，这个地方也运用了“懒标记”的思想。和 $remove$ 操作类似，将 $[L,R]$ 区间提取出来，可以把 $L-1\quad splay$ 到根结点，把 $R+1\quad splay$ 到根结点的儿子，如图。</p><p><img src="/2019/07/10/浅谈Splay/splay_5.png" alt></p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void reverse(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">int f=kth(l),s=kth(r+2);//因为prev，succ都是相对值，所以初始化要插入一个极大值和一个极小值。</span><br><span class="line"></span><br><span class="line">splay(f);</span><br><span class="line">splay(s,f);</span><br><span class="line">rev[son[s][0]]^=1;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们需要将标记下方，于是我们需要 $push_down$ 操作。在每次标记下放时交换左右儿子；</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline void push_down(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(!rev[x]) return;</span><br><span class="line">swap(son[x][0],son[x][1]);</span><br><span class="line">rev[son[x][0]]^=1;</span><br><span class="line">rev[son[x][1]]^=1;</span><br><span class="line">rev[x]=0;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续思考，我们什么时候需要下放标记？当且仅当翻转前后对答案有影响。在上述操作中，只有求第 $k$ 大（ $kth$ 操作）会有影响，因此，我们需要修改 $kth$ 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int kth(int ord)</span><br><span class="line">&#123;</span><br><span class="line">int x=root;</span><br><span class="line"></span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">push_down(x);//新增</span><br><span class="line">if(son[x][0]&amp;&amp;ord&lt;=siz[son[x][0]]) x=son[x][0];</span><br><span class="line">else if(ord&gt;siz[son[x][0]]+cnt[x])</span><br><span class="line">&#123;</span><br><span class="line">ord-=(siz[son[x][0]]+cnt[x]);</span><br><span class="line">x=son[x][1];</span><br><span class="line">&#125;</span><br><span class="line">else return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbf-output-操作"><a href="#mathbf-output-操作" class="headerlink" title="$\mathbf{output}$ 操作"></a>$\mathbf{output}$ 操作</h2><p>最后一个操作，输出！<br>注意输出时要下放标记。</p><p>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void output(int x)</span><br><span class="line">&#123;</span><br><span class="line">push_down(x);</span><br><span class="line">if(son[x][0]) output(son[x][0]);</span><br><span class="line">if(abs(val[x])!=inf)</span><br><span class="line">while(cnt[x]--) printf(&quot;%d &quot;,val[x]);</span><br><span class="line">if(son[x][1]) output(son[x][1]);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>$Splay$ 还可以实现更多操作，大都与区间打标记有关。 $Splay$ 标记下放与线段树类似，类比即可。</p><p>最后放一下模板题：<a href="https://www.luogu.org/problem/P3391" target="_blank" rel="noopener">LGOJ P3391 【模板】文艺平衡树（Splay）</a></p><p>std:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using std::swap;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">int ncnt=0,root=0,val[100005],cnt[100005],pre[100005],siz[100005],son[100005][2];</span><br><span class="line">bool rev[100005];</span><br><span class="line"></span><br><span class="line">inline int get_dir(int x)</span><br><span class="line">&#123;</span><br><span class="line">return son[pre[x]][1]==x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void push_up(int x)</span><br><span class="line">&#123;</span><br><span class="line">siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void push_down(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(!rev[x]) return;</span><br><span class="line">swap(son[x][0],son[x][1]);</span><br><span class="line">rev[son[x][0]]^=1;</span><br><span class="line">rev[son[x][1]]^=1;</span><br><span class="line">rev[x]=0;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void rotate(int x)</span><br><span class="line">&#123;</span><br><span class="line">int f=pre[x],g=pre[f],d=get_dir(x),s=son[x][d^1];</span><br><span class="line"></span><br><span class="line">son[f][d]=s;</span><br><span class="line">pre[s]=f;</span><br><span class="line">son[g][get_dir(f)]=x;</span><br><span class="line">pre[x]=g;</span><br><span class="line">son[x][d^1]=f;</span><br><span class="line">pre[f]=x;</span><br><span class="line">push_up(f);</span><br><span class="line">push_up(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splay(int x,int tar=0)</span><br><span class="line">&#123;</span><br><span class="line">while(pre[x]!=tar)</span><br><span class="line">&#123;</span><br><span class="line">int f=pre[x],g=pre[f];</span><br><span class="line"></span><br><span class="line">if(g!=tar)</span><br><span class="line">&#123;</span><br><span class="line">if(get_dir(x)==get_dir(f)) rotate(f);</span><br><span class="line">else rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">if(!tar) root=x;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find(int v)</span><br><span class="line">&#123;</span><br><span class="line">int x=root;</span><br><span class="line"></span><br><span class="line">if(!x) return;</span><br><span class="line">while(son[x][v&gt;val[x]]&amp;&amp;val[x]!=v)</span><br><span class="line">&#123;</span><br><span class="line">x=son[x][v&gt;val[x]];</span><br><span class="line">&#125;</span><br><span class="line">splay(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int v)</span><br><span class="line">&#123;</span><br><span class="line">int x=root,f=0;</span><br><span class="line"></span><br><span class="line">while(x&amp;&amp;val[x]!=v)</span><br><span class="line">&#123;</span><br><span class="line">f=x;</span><br><span class="line">x=son[x][v&gt;val[x]];</span><br><span class="line">&#125;</span><br><span class="line">if(x) ++cnt[x];</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">x=(++ncnt);</span><br><span class="line">if(f) son[f][v&gt;val[f]]=x;</span><br><span class="line">val[x]=v;</span><br><span class="line">cnt[x]=1;</span><br><span class="line">pre[x]=f;</span><br><span class="line">siz[x]=1;</span><br><span class="line">son[x][0]=0;</span><br><span class="line">son[x][1]=0;</span><br><span class="line">&#125;</span><br><span class="line">splay(x);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int kth(int ord)</span><br><span class="line">&#123;</span><br><span class="line">int x=root;</span><br><span class="line"></span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">push_down(x);</span><br><span class="line">if(son[x][0]&amp;&amp;ord&lt;=siz[son[x][0]]) x=son[x][0];</span><br><span class="line">else if(ord&gt;siz[son[x][0]]+cnt[x])</span><br><span class="line">&#123;</span><br><span class="line">ord-=(siz[son[x][0]]+cnt[x]);</span><br><span class="line">x=son[x][1];</span><br><span class="line">&#125;</span><br><span class="line">else return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rank(int v)</span><br><span class="line">&#123;</span><br><span class="line">find(v);</span><br><span class="line">return siz[son[root][0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int prev(int v)</span><br><span class="line">&#123;</span><br><span class="line">int u;</span><br><span class="line"></span><br><span class="line">find(v);</span><br><span class="line">u=son[root][0];</span><br><span class="line">while(son[u][1]) u=son[u][1];</span><br><span class="line"></span><br><span class="line">return u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int succ(int v)</span><br><span class="line">&#123;</span><br><span class="line">int u;</span><br><span class="line"></span><br><span class="line">find(v);</span><br><span class="line">u=son[root][1];</span><br><span class="line">while(son[u][0]) u=son[u][0];</span><br><span class="line"></span><br><span class="line">return u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int v)</span><br><span class="line">&#123;</span><br><span class="line">int p=prev(v),s=succ(v),tar;</span><br><span class="line"></span><br><span class="line">splay(p);</span><br><span class="line">splay(s,p);</span><br><span class="line">tar=son[p][0];</span><br><span class="line">if(cnt[tar]&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">--cnt[tar];</span><br><span class="line">splay(tar);</span><br><span class="line">&#125;</span><br><span class="line">else son[p][0]=0;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reverse(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">int f=kth(l),s=kth(r+2);</span><br><span class="line"></span><br><span class="line">splay(f);</span><br><span class="line">splay(s,f);</span><br><span class="line">rev[son[s][0]]^=1;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int x)</span><br><span class="line">&#123;</span><br><span class="line">push_down(x);</span><br><span class="line">if(son[x][0]) output(son[x][0]);</span><br><span class="line">if(abs(val[x])!=inf)</span><br><span class="line">while(cnt[x]--) printf(&quot;%d &quot;,val[x]);</span><br><span class="line">if(son[x][1]) output(son[x][1]);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">insert(-inf);</span><br><span class="line">insert(inf);</span><br><span class="line">for(register int i=1;i&lt;=n;++i) insert(i);</span><br><span class="line"></span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">int L,R;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;L,&amp;R);</span><br><span class="line"></span><br><span class="line">reverse(L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output(root);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
